package com.euc.flash.model{	import com.euc.flash.events.ModelChangeEvent;
	import com.euc.flash.utils.Delegate;
	import com.euc.flash.utils.ObjectInfoUtil;
	import com.euc.flash.utils.StringInfoUtil;
	
	import flash.events.EventDispatcher;
	import flash.utils.Timer;

	public class BindableModel extends EventDispatcher	{		public var debugEnabled:Boolean = true;		protected var notificationDelay:int = 10;	// 딜레이 카운트		protected var pendingNotification:Timer;	// 타이머		protected var currentValues:Object;			// 현재 속성값		protected var pendingValues:Object;			// 나중 속성값		protected var changedProperties:Array;		// 바뀐 속성 배열		private var _isAlwayDispatch:Boolean;		// 항상 디스페치 여부		/**		 *  Constructor.		 */ 		public function BindableModel()		{			currentValues = {};			pendingValues = {};			changedProperties = [];		}		/**		 * get property by name		 */		protected function get( property:String ):*		{			if ( pendingValues[property] !== undefined )				return pendingValues[property];							return currentValues[property];		}		/**		 * set property by name		 */		protected function set( property:String, newValue:*, isAlwayDispatch:Boolean=false ):void		{			_isAlwayDispatch = isAlwayDispatch;						if ( !equal( currentValues[property] , newValue ) )			{				pendingValues[property] = newValue;				invalidate( property );			}			else			{				validate( property );			}			if ( isAlwayDispatch ) dispatchModelChangeEvent( property, newValue, currentValues[property] );		}		/**		 * Uses byteArray comparison to determine if two values are equal		 */		protected function equal( val1:*, val2:* ):Boolean		{			return ObjectInfoUtil.equals(val1, val2);		}		/**		 * Triggers a notification that a property has changed		 *		 * Notification happens after a brief delay, so that multiple		 * changes can be gathered together and broadcast as a group.		 */		protected function invalidate( property:String ):void		{			if ( changedProperties.indexOf(property) != -1 ) return;						changedProperties.push( property );			Delegate.cancel( pendingNotification );			pendingNotification = Delegate.callLater( notificationDelay, notifyChanged );		}		/**		 * Removes property from changedProperties list and cancels pending notification		 */		protected function validate( property:String ):void		{			var i:int = changedProperties.indexOf( property );			if (i != -1)			{				changedProperties.splice(i, 1);			}			pendingValues[property] = undefined;			if ( changedProperties.length == 0 )			{				Delegate.cancel( pendingNotification );			}		}		/**		 * Loops through list of changedProperties and dispatches a ModelChangeEvent for each one		 *		 * Here is also where we update the currentValues array and reset the		 * changedProperties list and pendingValues Object		 */		protected function notifyChanged():void		{			for each ( var property:String in changedProperties )			{				var newValue:* = pendingValues[property];				var oldValue:* = currentValues[property];				var logVal:String = newValue != null ? StringInfoUtil.abbreviate( newValue.toString() ) : 'null';				if ( newValue is Array )				{					logVal = "Array(" + (newValue as Array).length + ") : " + logVal;				}				debug( 'changed "'+ property + '" to ' + logVal );				currentValues[property] = pendingValues[property];								if ( !_isAlwayDispatch ) dispatchModelChangeEvent( property, newValue, oldValue );			}			changedProperties = [];			pendingValues = {};		}		private function dispatchModelChangeEvent( property:String, newValue:*, oldValue:* ):void		{			dispatchEvent( new ModelChangeEvent( this, property, newValue, oldValue ) );		}		/**		 * trace		 */		protected function debug( message:String ):void		{			if (!debugEnabled)				return;			trace( this + ' ' + message );		}		override public function toString():String		{			return "[Model]";		}	}}