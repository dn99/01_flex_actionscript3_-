package com.euc.flash.utils{	import flash.net.registerClassAlias;	import flash.utils.ByteArray;	import flash.utils.Dictionary;	import flash.utils.Proxy;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;		import mx.utils.ObjectUtil;
	/**	 * Object cloning and comparison utilities	 * 	 * This code was inspired by and borrowed from the 	 * Flight Framework Type utility.	 * 	 * @author David Knape	 */	public class ObjectInfoUtil {		private static var registeredTypes:Dictionary = new Dictionary();		/**		 *  두개의 오브젝트를 비교하여 같은지 여부를 반환		 *  @param value1 대상 오브젝트1.		 *  @param value2 대상 오브젝트2.		 *  @return Boolean.		 */ 		public static function equals( value1:Object, value2:Object ):Boolean 		{			if(value1 == value2) return true;			if(value1==null || value2==null) return false;						ObjectInfoUtil.registerType(value1);						var so1:ByteArray = new ByteArray();			so1.writeObject(value1);	        			var so2:ByteArray = new ByteArray();			so2.writeObject(value2);						return Boolean(so1.toString() == so2.toString());		}		/**		 *  오브제트 복사		 *  @param value 카피할 대상 오브젝트.		 *  @return Object		 */		public static function clone( value:Object ):Object 		{			if(value==null) return null;						ObjectInfoUtil.registerType(value);						var so:ByteArray = new ByteArray();			so.writeObject(value);	        			so.position = 0;			return so.readObject();		}                       		/**		 * Registers the class alias for this object so it can be		 * cloned and compared as a byteArray		 */		public static function registerType( value:Object ):Boolean 		{			if( !(value is Class) ) value = getType(value);						if(!registeredTypes[value]) 			{						registeredTypes[value] = registerClassAlias(getQualifiedClassName(value).split("::").join("."), value as Class);			}						return true;		}  				/**		 * Get the class name for an object		 */		public static function getType( value:Object ):Class 		{			if (value is Class) 			{				return value as Class;			} 			else if(value is Proxy) 			{				return getDefinitionByName(getQualifiedClassName(value)) as Class;			}			else 			{				return value.constructor as Class;			}		}      				/**		 *  속성을 합침		 *  @param source 소스.		 *  @target 대상.		 */ 		public static function mergeProperties( source:*, target:* ) : void 		{			if(source!=null && target!=null)			for( var property_name:String in source ) 			{				try 				{ 					target[property_name] = source[property_name];				} catch (e:Error) {}			}		}				/**		 *  오브젝트 속성 중 해당 속성 존재 유무 여부		 * 	@param obj 속성 존재 유무 여부를 체크할 오브젝트.		 * 	@param name 체크할 속성 네임.		 *  @return Boolean		 */		public static function hasExistName( obj:Object, name:String ):Boolean		{			var isExist:Boolean = false;						var objInfo:Object = ObjectUtil.getClassInfo( obj );			for each ( var nameInfo:String in objInfo.properties )			{				if ( name == nameInfo ) 				{					isExist = true;					break;				}			}						return isExist;		}	}}